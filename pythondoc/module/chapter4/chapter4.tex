%#-*- coding:utf-8 -*-
\chapter{内建类型}
\section{Truth Value Testing}
\section{Boolean Operations--and, or, not}
\section{Comparisons}
\section{Numeric Types--int, float, complex}
\section{Iterator Types}




\section{Sequence Types--list, tuple, range}
\subsection{Common sequence operations}
\begin{center}
\begin{tabular}{|l|l|}\hline
操作                &               结果 \\\hline
x in s              &               True if an item of s is equal to x, else False \\\hline
x not in s          &               False if an item of s is equal to x, else True \\\hline
s + t               &               the concatenation os s and t \\\hline
s*n or n*s          &               equivalent to adding s to iteself n times \\\hline
s[i]                &               ith item of s, origin 0 \\\hline
s[i:j]              &               slice of s from i to j \\\hline
s[i:j:k]            &               slice of s from i to j with step k \\\hline
len(s)              &               length of s \\\hline
min(s)              &               smallest item of s \\\hline
max(s)              &               largest item of s \\\hline
s.index(x[, i[, j]])&               index of the first occurrence of x in s\\\hline
s.count(x)          &               total number of occurrences of x in s \\\hline
\end{tabular}
\end{center}

\subsection{不可变序列类型}



\subsection{改变序列类型}
\begin{center}
  \begin{tabular}{|l|l|} \hline
    s[i] = x         & item i of s is replaced by x \\\hline
    s[i:j] = t       & slice of s from i to j is replaced by the contents of the iterable t \\\hline
    del s[i:j]       & same as s[i:j] = [] \\\hline
    s[i:j:k] = t     & the elements of s[i:j:k] are replaced by those of t \\\hline
    del s[i:j:k]     & removes the elements of s[i:j:k] from the list \\\hline
    s.append(x)      & appends x to the end of the sequence \\\hline
    s.clear()        & removes all items from s (same as del s[:]) \\\hline
    s.copy()         & creates a shallow copy of s (same as s[:]) \\\hline
    s.extend(t) or s += t & extends s with the contents of t \\\hline
    s *= n           & updates s with its contents repeated n times \\\hline
    s.insert(i, x)   & inserts x into s at the index given by i \\\hline
    s.pop([i])       & retrieves the item at i and also removes it from s \\\hline
    s.remove(x)      & remove the first item from s where s[i] == x \\\hline
    s.reverse()      & reverses the items of s in place \\\hline

  \end{tabular}
\end{center}



\subsection{Lists}
\noindent{\color{red}{list([iterable]):}}
\par{创建列表的方式：}
  \begin{enumerate}
  \item 使用一对中括号。
  \item 一对中括号包含的逗号分割的元素。
  \item 列表解析[x for x in iterable]。
  \item 使用list()函数。
  \end{enumerate}


\noindent{\color{red}{[].sort(*, key=None, reverse=False):}}
\par{对列表进行原地排序。}\\

\subsection{Tuples}
\noindent{\color{red}{tuple([iterable]):}}
\par{创建元组的方式：}
  \begin{enumerate}
  \item 使用圆括号。
  \item 使用逗号进行分割：a, 或者(a, )。
  \item 圆括号包围的逗号分割的元素：a, b, c 或者(a, b, c)。
  \item 使用tuple()函数。
  \end{enumerate}

\subsection{Ranges}
\noindent{\color{red}{range(stop):}}\\
\noindent{\color{red}{range(start, stop[, step]):}}
\par{创建range()的方式。}
  \begin{enumerate}
  \item start是起始参数。
  \item stop是中之参数，但是不包含stop的数值。
  \item step是步长参数。
  \end{enumerate}








\section{Text Sequence Type--str}
\subsection{String Methods}
\noindent{\color{red}{str.capitalize():}}
\par{把字符串的第一个字母大写}\\

\noindent{\color{red}{str.casefold():}}
\par{可识别更多的对象将其输出为小写，类似str.lower()函数。}\\

\noindent{\color{red}{str.center(width[, fillchar]):}}
\par{返回一个原字符串剧中，并使用空格填充至长度width的新字符串。}\\

\noindent{\color{red}{str.count(sub[, start[, end]]):}}
\par{返回sub在str中出现的次数，如果start和end指定，则返回指定范围内sub的出现的次数。}\\

\noindent{\color{red}{str.encode(encoding=\textquotedblleft utf-8\textquotedblright,
errors=\textquotedblleft{strict}\textquotedblright):}}
\par{以encoding指定的格式编码str。}\\

\noindent{\color{red}{str.endswith(suffix[, start[, end]]):}}
\par{检查字符串是否以suffix结束，如果start和end指定范围则检查指定的范围内是否以suffix结束，如
果是，返回True,否则返回False。}\\

\noindent{\color{red}{str.expandtabs(tabsize=8):}}
\par{把字符串str中的tab符号转换为空格，默认的宽度为8。}\\

\noindent{\color{red}{str.find(sub[, start[, end]]):}}
\par{检查sub是否包含在str中，如果start和end指定范围，则检查是否包含在指定的范围内。如果是则
返回开始的索引值，否则返回-1。}\\

\noindent{\color{red}{str.format(*args, **kwargs):}}
\par{未知}\\

\noindent{\color{red}{str.format\_map(mapping):}}
\par{未知}\\

\noindent{\color{red}{str.index(sub[, start[, end]]):}}
\par{和find()类似，只不过如果没找到报ValueError类型的错误。}\\

\noindent{\color{red}{str.isalnum():}}
\par{如果str至少有一个字符并且所有字符都是字母或者数字则返回True，否则返回False。}\\

\noindent{\color{red}{str.isalpha():}}
\par{如果str至少有一个字符并且所有字符都是字母则返回true，否则返回False。}\\

\noindent{\color{red}{str.isdecimal():}}
\par{如果str至少有一个字符并且所有字符都是十进制数字则返回true，否则返回False。}\\

\noindent{\color{red}{str.isdigit():}}
\par{如果str至少有一个字符并且所有字符都是数字则返回true，否则返回False。}\\

\noindent{\color{red}{str.isidentifier():}}
\par{未知}\\

\noindent{\color{red}{str.islower():}}
\par{如果str中包含至少一个区分大小写的字符，并且所有的字符都是小写，则返回True，否则返回False。}\\

\noindent{\color{red}{str.isnumeric():}}
\par{如果str中只包含数字字符，则返回True，否则返回False。}\\

\noindent{\color{red}{str.isprintable():}}
\par{如果str中的字符都是可打印的或者为空，则返回True，否则返回False。}\\

\noindent{\color{red}{str.isspace():}}
\par{如果str中只包含空格，则返回True，否则返回False。}\\

\noindent{\color{red}{str.istitle():}}
\par{如果str是标题化的，则返回True，否则返回False。}\\




\section{Binary Sequence Types}





\section{Set Types}





\section{Mapping Types}





\section{Context Manager Types}





\section{Other Build-in Types}





\section{Special Attributes}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
